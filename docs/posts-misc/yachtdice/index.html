<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Drydan’s Portfolio - Searching for Johnny Yacht Dice</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../posts-misc/yachtdice/index.html">Yacht Dice</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      <img src="../../images/pfp.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../posts-hockey/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hockey Analytics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts-hockey/player-positions/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Player Positions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts-hockey/rapm/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RAPM Models</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts-misc/yachtdice/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Yacht Dice</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../posts-misc/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Random Stuff</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts-misc/pipelines/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Partitioning a Pipeline</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Searching for Johnny Yacht Dice</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Yacht is a game played with five dice. Players have twelve turns to score as many points as possible using the dice values to form hands. Each turn is played as such: 1. Roll all five dice 2. Select which dice to keep and reroll the rest. This action can be repeated once more. 3. Select a category used to score the hand and add it to your current point total. A player cannot select a category more than once a game.</p>
<p>There are 12 possible categories to select:</p>
<table class="table">
<thead>
<tr class="header">
<th>Single Digit/Bonus Hands</th>
<th>Scoring</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ones</td>
<td>Only sum the dice that rolled a 1</td>
</tr>
<tr class="even">
<td>Twos</td>
<td>Only sum the dice that rolled a 2</td>
</tr>
<tr class="odd">
<td>Threes</td>
<td>Only sum the dice that rolled a 3</td>
</tr>
<tr class="even">
<td>Fours</td>
<td>Only sum the dice that rolled a 4</td>
</tr>
<tr class="odd">
<td>Fives</td>
<td>Only sum the dice that rolled a 5</td>
</tr>
<tr class="even">
<td>Sixes</td>
<td>Only sum the dice that rolled a 6</td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Standard Hands</th>
<th>Scoring</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Choice</td>
<td>Sum all dice values</td>
</tr>
<tr class="even">
<td>Full House</td>
<td>If three dice share the same value and the remaining two are the same sum all dice otherwise score 0</td>
</tr>
<tr class="odd">
<td>Four of a Kind</td>
<td>If four or more dice share the same value sum all dice otherwise score 0</td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Binary Hands</th>
<th>Scoring</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small Straight</td>
<td>If four dice form a sequence of consecutive numbers score 15 otherwise score 0</td>
</tr>
<tr class="even">
<td>Large Straight</td>
<td>If all five dice form a sequence of consecutive numbers score 30 otherwise score 0</td>
</tr>
<tr class="odd">
<td>Yacht</td>
<td>If all dice have the same value score 50 otherwise score 0</td>
</tr>
</tbody>
</table>
<p>If a player scores 63 or more points from the Bonus Hand Categories, they receive an additional 35 points.</p>
<p>After a couple of games, ideas on optimal play will start to percolate in your head. Let’s explore them in python.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.gridspec <span class="im">import</span> GridSpec</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>First we’ll create a list of all possible rolls and record their scores for each of the 12 hands.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>rolls <span class="op">=</span> <span class="bu">list</span>(<span class="st">''</span>.join(i) <span class="cf">for</span> i <span class="kw">in</span> itertools.combinations_with_replacement(<span class="st">'123456'</span>, r<span class="op">=</span><span class="dv">5</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>n_rolls <span class="op">=</span> <span class="bu">len</span>(rolls)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>hands <span class="op">=</span> [</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ones'</span>,<span class="st">'twos'</span>,<span class="st">'threes'</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'fours'</span>,<span class="st">'fives'</span>,<span class="st">'sixes'</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'choice'</span>,<span class="st">'fourKind'</span>,<span class="st">'fullHouse'</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'smallStraight'</span>,<span class="st">'largeStraight'</span>,<span class="st">'yacht'</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>n_hands <span class="op">=</span> <span class="bu">len</span>(hands)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalFourKind(count):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.dot(countArray,<span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>)) <span class="cf">if</span> (<span class="bu">max</span>(count) <span class="op">&gt;=</span> <span class="dv">4</span>) <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalFullhouse(count):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">max</span>(count) <span class="op">==</span> <span class="dv">5</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.dot(countArray,<span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>))</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> (<span class="dv">3</span> <span class="kw">in</span> count) <span class="op">&amp;</span> (<span class="dv">2</span> <span class="kw">in</span> count):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.dot(countArray,<span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>))</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalSmallStraight(count):</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    straights <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">7</span>],[<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">7</span>],[<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]]</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">sum</span>(count[j] <span class="op">&gt;=</span> straights[i][j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>)) <span class="op">&gt;=</span> <span class="dv">4</span>:</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">15</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span>      </span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalLargeStraight(count):</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">30</span> <span class="cf">if</span> ((count <span class="op">==</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]) <span class="kw">or</span> (count <span class="op">==</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>])) <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalYacht(count):</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">50</span> <span class="cf">if</span> (<span class="dv">5</span> <span class="kw">in</span> count) <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co"># store scores recieved based on roll and hand selected</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>base_hand_value_matrix <span class="op">=</span> np.zeros((n_rolls, n_hands))</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">range</span>(n_rolls):</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    roll <span class="op">=</span> rolls[idx]</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convert roll to array with first entry storing number of ones rolled...</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    countArray <span class="op">=</span> [roll.count(<span class="bu">str</span>(i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>)]</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    base_hand_value_matrix[idx] <span class="op">=</span> [</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>[countArray[i] <span class="op">*</span> (i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>)],</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        np.dot(countArray, <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>)),</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        evalFourKind(countArray),</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        evalFullhouse(countArray),</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        evalSmallStraight(countArray),</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        evalLargeStraight(countArray),</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        evalYacht(countArray)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    ] </span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'There are </span><span class="sc">{}</span><span class="st"> possible rolls'</span>.<span class="bu">format</span>(n_rolls))</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co"># test scoring functions</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'hand = </span><span class="sc">{</span>rolls[idx]<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">----'</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> hands:</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>base_hand_value_matrix[idx, hands.index(i)]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>There are 252 possible rolls
hand = 11166 
----
ones = 3.0
twos = 0.0
threes = 0.0
fours = 0.0
fives = 0.0
sixes = 12.0
choice = 15.0
fourKind = 0.0
fullHouse = 15.0
smallStraight = 0.0
largeStraight = 0.0
yacht = 0.0</code></pre>
<p>For each reroll we have to decide which dice to hold onto. Let’s create a list of all possible options.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let 1 indicate we keep the dice, 0 indicate we reroll it</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>keeps <span class="op">=</span> <span class="bu">list</span>([<span class="st">''</span>.join(i) <span class="cf">for</span> i <span class="kw">in</span> itertools.product(<span class="st">'01'</span>,repeat<span class="op">=</span><span class="dv">5</span>)])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>n_keeps <span class="op">=</span> <span class="bu">len</span>(keeps)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'There are </span><span class="sc">{}</span><span class="st"> options during the reroll phase'</span>.<span class="bu">format</span>(n_keeps))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>There are 32 options during the reroll phase</code></pre>
<p>It will be useful to know the probability of transitioning from one roll to another given which dice we choose to keep.</p>
<p>We can store the probabilities in a 252x32x252 matrix.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>state_transition_matrix <span class="op">=</span> np.zeros((n_rolls, n_keeps, n_rolls))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frequencies(items):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> {}</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> items:</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        counts[i] <span class="op">=</span> counts.get(i, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {k: v<span class="op">/</span><span class="bu">len</span>(items) <span class="cf">for</span> k, v <span class="kw">in</span> counts.items()}</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># dict containing all possible rolls using i dice</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>freq <span class="op">=</span> {}</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num_to_reroll <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    freq[num_to_reroll] <span class="op">=</span> <span class="bu">list</span>(itertools.product(<span class="st">'123456'</span>,repeat<span class="op">=</span>num_to_reroll))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> state <span class="kw">in</span> <span class="bu">range</span>(n_rolls):</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    roll <span class="op">=</span> rolls[state] <span class="co"># what is our current roll</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> action <span class="kw">in</span> <span class="bu">range</span>(n_keeps):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        dice_to_keep <span class="op">=</span> keeps[action]  <span class="co"># select which dice to keep</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        kept_dice <span class="op">=</span> <span class="st">''</span>.join(roll[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>) <span class="cf">if</span> dice_to_keep[i] <span class="op">==</span> <span class="st">'1'</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        num_to_reroll <span class="op">=</span> <span class="dv">5</span><span class="op">-</span><span class="bu">len</span>(kept_dice)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get all possible new rolls with probability  </span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        new_rolls <span class="op">=</span> [<span class="st">''</span>.join(<span class="bu">sorted</span>(kept_dice <span class="op">+</span> <span class="st">''</span>.join(new_roll))) <span class="cf">for</span> new_roll <span class="kw">in</span> freq[num_to_reroll]]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> frequencies(new_rolls)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># store in state_transition_matrix</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> new_roll <span class="kw">in</span> f:</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>           new_state <span class="op">=</span> rolls.index(new_roll)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>           state_transition_matrix[state, action, new_state] <span class="op">=</span> f[new_roll]</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>initial_roll_probs <span class="op">=</span> state_transition_matrix[<span class="dv">0</span>, <span class="dv">0</span>, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s check what the probability of moving from five ones to a full house, ones over sixes. To do this we keep 3 ones and reroll the rest. We know this is 1/36, which equals 0.02777.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>init_state <span class="op">=</span> rolls.index(<span class="st">'11111'</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>term_state <span class="op">=</span> rolls.index(<span class="st">'11166'</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>action <span class="op">=</span> keeps.index(<span class="st">'11100'</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Probability of rolling "11166" from "11111" = </span><span class="sc">{</span>state_transition_matrix[init_state, action, term_state]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Probability of rolling "11166" from "11111" = 0.027777777777777776</code></pre>
<p>Now let’s find the expected value of each hand prior to first roll, given we only make decisions to maximize said hand. We will need a policy to decide which dice to keep for two rerolls. The policy can be obtained using the transition probabilities and working backwards starting from the hand values after the last roll. We’ll use numpy’s einsum function to achieve this.</p>
<p>Recall state_transition_matrix is a 252x32x252 matrix whose i,j,k dimensions indicate the initial roll, the 32 options to keep dice before rerolling, and the terminal roll. The entries correspond to the probability of landing on the terminal roll given which dice we chose to keep from the initial roll. The base_hand_value_matrix is a 252x12 matrix whose k,l dimensions indicate the terminal roll before we chose which of the 12 hands to select, and entries indicate the value of that selection. When we input ‘ijk,kl-&gt;ijl’ into einsum, we are informing the function to return a 252x32x12 matrix with entry i,j,l corresponding to the dot product of two 252 length vectors state_transition_matrix[i,j,:] and base_hand_value_matrix[:,l], or the expected value of our current roll after selecting which dice to keep and which hand to score. Now consider always taking the action which maximizes the expected value, we can reduce our 252x32x12 matrix output to a 252x12 matrix. This matrix, called ex_val_1_reroll_left, stores the expected value of each hand given our current state with one reroll left. We can repeat the procedure by replacing base_hand_value_matrix with ex_val_1_reroll_left to get the expected values with two reroll left. Finally we can multiply a vector probabilities for each roll at the start of the round by ex_val_2_reroll_left to obtain our solution.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ex_val_1_reroll_left <span class="op">=</span> np.einsum(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ijk,kl-&gt;ijl'</span>, </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    state_transition_matrix, </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    base_hand_value_matrix</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>ex_val_2_reroll_left <span class="op">=</span> np.einsum(</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ijk,kl-&gt;ijl'</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    state_transition_matrix,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    ex_val_1_reroll_left</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>ex_val_preroll <span class="op">=</span> state_transition_matrix[<span class="dv">0</span>,keeps.index(<span class="st">'00000'</span>),:] <span class="op">@</span> ex_val_2_reroll_left</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="bu">dict</span>(<span class="bu">zip</span>(hands,ex_val_preroll))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>{'ones': 2.106481481481479,
 'twos': 4.212962962962959,
 'threes': 6.319444444444442,
 'fours': 8.425925925925918,
 'fives': 10.532407407407414,
 'sixes': 12.638888888888884,
 'choice': 23.33333333333333,
 'fourKind': 5.611263427672356,
 'fullHouse': 7.013552612731233,
 'smallStraight': 9.231634693554096,
 'largeStraight': 7.83285050202343,
 'yacht': 2.3014321262849484}</code></pre>
<p>Most of the time we will have more than one option when selecting a hand to score at the end of the round. We need to create a policy for all the possible combinations of available hands.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let 0 indicate the hand is available to score, 1 indicates it is unavailabile</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>available_hands <span class="op">=</span> [<span class="st">''</span>.join(i) <span class="cf">for</span> i <span class="kw">in</span> itertools.product(<span class="st">'01'</span>,repeat<span class="op">=</span>n_hands)][:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>n_available_hands <span class="op">=</span> <span class="bu">len</span>(available_hands)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>There are 4095 possible senarios for which hands are still available in a game that has not ended.</code></pre>
<p>Let’s create a policy whose only concern is to maximize the score received at the end a turn.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># useful for calcs</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>available_hand_matrix <span class="op">=</span> np.zeros((n_available_hands, n_hands))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(n_available_hands):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    ah <span class="op">=</span> available_hands[a]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    available_hand_matrix[a] <span class="op">=</span> [np.NINF <span class="cf">if</span> i<span class="op">==</span><span class="st">'1'</span> <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">list</span>(ah)]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>avail_hand_and_roll_indices <span class="op">=</span> np.indices((<span class="bu">len</span>(available_hands),<span class="bu">len</span>(rolls)))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_simple_policy(hand_value_matrix):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Creates a greedy policy using a hand_value_matrix</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Output : </span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">        state_policy_dict = {</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">            0: (4095x252 matrix) w/ entries 0-11 referring to selecting an available hand at end of round</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">            1: (4095x252 matrix) w/ entries 0-31 referring to which dice to keep at second reroll</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">            2: (4095x252 matrix) w/ entries 0-31 referring to which dice to keep at first reroll</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">        }</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Globally Referenced Variables: state_transition_matrix, available_hand_matrix, avail_hand_and_roll_indices</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    state_policy_dict <span class="op">=</span> {}</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    state_value_dict <span class="op">=</span> {}</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># select hand at final step from those available which maximized score obtained in round:</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> hand_value_matrix[<span class="va">None</span>,:,:]<span class="op">+</span>available_hand_matrix[:,<span class="va">None</span>,:]</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    state_policy_dict[<span class="dv">0</span>] <span class="op">=</span> np.argmax(b,axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    state_value_dict[<span class="dv">0</span>] <span class="op">=</span>  b[(<span class="op">*</span>avail_hand_and_roll_indices,state_policy_dict[<span class="dv">0</span>])]</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculate reroll policies and expected values:</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># replace einsum with tensordot for speed improvement</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> np.tensordot(state_value_dict[<span class="dv">0</span>], state_transition_matrix, axes<span class="op">=</span>((<span class="dv">1</span>),(<span class="dv">2</span>)))</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    state_policy_dict[<span class="dv">1</span>] <span class="op">=</span> np.argmax(a,axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    state_value_dict[<span class="dv">1</span>] <span class="op">=</span>  a[(<span class="op">*</span>avail_hand_and_roll_indices,state_policy_dict[<span class="dv">1</span>])]</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> np.tensordot(state_value_dict[<span class="dv">1</span>], state_transition_matrix, axes<span class="op">=</span>((<span class="dv">1</span>),(<span class="dv">2</span>)))</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    state_policy_dict[<span class="dv">2</span>] <span class="op">=</span> np.argmax(a,axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">#state_value_dict[2] =  a[(*avail_hand_and_roll_indices,state_policy_dict[2])]</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state_policy_dict <span class="co">#, state_value_dict</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>old_state_policy_dict <span class="op">=</span> create_simple_policy(base_hand_value_matrix)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit create_simple_policy(base_hand_value_matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>809 ms ± 63.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
<p>Now let’s check which actions our policy takes in certain scenarios.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>rerolls_left <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>init_state <span class="op">=</span> rolls.index(<span class="st">'11123'</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>ah_idx <span class="op">=</span> available_hands.index(<span class="st">'000000000000'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>action <span class="op">=</span> old_state_policy_dict[rerolls_left][ah_idx, init_state]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(keeps[action])</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>rerolls_left <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>init_state <span class="op">=</span> rolls.index(<span class="st">'11123'</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ah_idx <span class="op">=</span> available_hands.index(<span class="st">'011111111111'</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>action <span class="op">=</span> old_state_policy_dict[rerolls_left][ah_idx, init_state]</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(keeps[action])</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>rerolls_left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>init_state <span class="op">=</span> rolls.index(<span class="st">'11123'</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>ah_idx <span class="op">=</span> available_hands.index(<span class="st">'000000000000'</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>action <span class="op">=</span> old_state_policy_dict[rerolls_left][ah_idx, init_state]</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hands[action])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>00000
11100
choice</code></pre>
<p>So if we open the game rolling 1,1,1,2,3 our policy wants us to reroll everything. It also correctly determines to only keep ones when “ones” is the only hand left to score. Now the last piece of advice is alarming. When all hands are available it opts to score using choice. That gives us 8 out of a potential 30 points. If instead it opted for ones, it would leave just 2 points on the table. We’ve created a greedy algorithm!</p>
<p>Now let’s build some agents and test out their prowess.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> yachtDiceAgent:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>, </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        state_policy_dict, </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        init_availHandsId<span class="op">=</span><span class="dv">0</span>, </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        init_game_score<span class="op">=</span><span class="dv">0</span>, </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        init_bonus_progress<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        bonus_progress_required<span class="op">=</span><span class="dv">63</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        bonus_reward<span class="op">=</span><span class="dv">35</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state_policy_dict <span class="op">=</span> state_policy_dict</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.score_keeper <span class="op">=</span> []</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bonus_keeper <span class="op">=</span> []</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hand_keeper <span class="op">=</span> []</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.init_availHandsId <span class="op">=</span> init_availHandsId</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.init_game_score <span class="op">=</span> init_game_score</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.init_bonus_progress <span class="op">=</span> init_bonus_progress</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bonus_progress_required <span class="op">=</span> bonus_progress_required</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bonus_reward <span class="op">=</span> bonus_reward</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _rollDice(<span class="va">self</span>, keep, diceRoll):</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        newRoll <span class="op">=</span> <span class="st">''</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> keep[i] <span class="op">==</span> <span class="st">'0'</span>:</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>                newRoll <span class="op">+=</span> <span class="bu">str</span>(np.random.randint(<span class="dv">1</span>, <span class="dv">7</span>))</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                newRoll <span class="op">+=</span> diceRoll[i]</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        diceRoll <span class="op">=</span> <span class="st">''</span>.join(<span class="bu">sorted</span>(newRoll))</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        diceRollId <span class="op">=</span> rolls.index(diceRoll)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> diceRoll, diceRollId</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_action(<span class="va">self</span>, availHandsId, bonus_progress, rerolls_left, diceRollId):</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.state_policy_dict[rerolls_left][availHandsId, diceRollId]</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_game(<span class="va">self</span>):</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initialize game</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>        availHandsId <span class="op">=</span> <span class="va">self</span>.init_availHandsId</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>        game_score <span class="op">=</span> <span class="va">self</span>.init_game_score</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>        bonus_progress <span class="op">=</span> <span class="va">self</span>.init_bonus_progress</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> np.zeros(<span class="dv">12</span>)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>        turn <span class="op">=</span> available_hands[availHandsId].count(<span class="st">'1'</span>)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># play out game</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> turn <span class="op">&lt;</span> <span class="dv">12</span>:</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># initial roll</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>            <span class="co"># note: there's a noticable improvement to preformance by assigning diceRoll to local vs. instance</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>            diceRoll, diceRollId <span class="op">=</span> <span class="va">self</span>._rollDice(keeps[<span class="dv">0</span>], <span class="st">'11111'</span>)</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>            <span class="co"># two rerolls </span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> rerolls_left <span class="kw">in</span> [<span class="dv">2</span>,<span class="dv">1</span>]:</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>                action <span class="op">=</span> <span class="va">self</span>.get_action(availHandsId, bonus_progress, rerolls_left, diceRollId)</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>                diceRoll, diceRollId <span class="op">=</span> <span class="va">self</span>._rollDice(keeps[action], diceRoll)</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>            <span class="co"># select hand</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>            action <span class="op">=</span> <span class="va">self</span>.get_action(availHandsId, bonus_progress, <span class="dv">0</span>, diceRollId)</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>            availHandsId <span class="op">+=</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">11</span><span class="op">-</span>action)</span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>            <span class="co"># end turn</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>            points[action] <span class="op">+=</span> base_hand_value_matrix[diceRollId, action]</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>            turn <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># evaluate score</span></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>            bonus_progress <span class="op">=</span> <span class="bu">int</span>(<span class="bu">min</span>(<span class="va">self</span>.bonus_progress_required, <span class="va">self</span>.init_bonus_progress <span class="op">+</span> <span class="bu">sum</span>(points[:<span class="dv">6</span>])))</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>        game_score <span class="op">+=</span> <span class="bu">sum</span>(points) <span class="op">+</span> <span class="va">self</span>.bonus_reward<span class="op">*</span>(bonus_progress <span class="op">&gt;=</span> <span class="va">self</span>.bonus_progress_required)</span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># record stats</span></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.score_keeper.append(game_score)</span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bonus_keeper.append(bonus_progress <span class="op">&gt;=</span> <span class="va">self</span>.bonus_progress_required)</span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hand_keeper.append(points)</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_games(<span class="va">self</span>, n_sims):</span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_sims):</span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.simulate_game()</span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> summarize_results(<span class="va">self</span>, name<span class="op">=</span><span class="st">''</span>, color<span class="op">=</span><span class="st">'b'</span>, n_bins<span class="op">=</span><span class="dv">40</span>, max_score<span class="op">=</span><span class="dv">323</span>):</span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a>        n_sims <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.score_keeper)</span>
<span id="cb17-72"><a href="#cb17-72" aria-hidden="true" tabindex="-1"></a>        avg_score <span class="op">=</span> np.mean(<span class="va">self</span>.score_keeper)</span>
<span id="cb17-73"><a href="#cb17-73" aria-hidden="true" tabindex="-1"></a>        avg_bonus <span class="op">=</span> <span class="dv">100</span><span class="op">*</span>np.mean(<span class="va">self</span>.bonus_keeper)</span>
<span id="cb17-74"><a href="#cb17-74" aria-hidden="true" tabindex="-1"></a>        hand_matrix <span class="op">=</span> np.vstack(<span class="va">self</span>.hand_keeper)</span>
<span id="cb17-75"><a href="#cb17-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-76"><a href="#cb17-76" aria-hidden="true" tabindex="-1"></a>        fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb17-77"><a href="#cb17-77" aria-hidden="true" tabindex="-1"></a>        gs <span class="op">=</span> GridSpec(<span class="dv">3</span>, <span class="dv">6</span>, figure<span class="op">=</span>fig)</span>
<span id="cb17-78"><a href="#cb17-78" aria-hidden="true" tabindex="-1"></a>        fig.add_subplot(gs[:, :<span class="dv">3</span>])</span>
<span id="cb17-79"><a href="#cb17-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">9</span>):</span>
<span id="cb17-80"><a href="#cb17-80" aria-hidden="true" tabindex="-1"></a>            fig.add_subplot(gs[i<span class="op">//</span><span class="dv">3</span>, (i<span class="op">%</span><span class="dv">3</span>)<span class="op">-</span><span class="dv">3</span>])</span>
<span id="cb17-81"><a href="#cb17-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-82"><a href="#cb17-82" aria-hidden="true" tabindex="-1"></a>        fig.axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Possible Scores'</span>)</span>
<span id="cb17-83"><a href="#cb17-83" aria-hidden="true" tabindex="-1"></a>        fig.axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Count'</span>)</span>
<span id="cb17-84"><a href="#cb17-84" aria-hidden="true" tabindex="-1"></a>        fig.axes[<span class="dv">0</span>].set_title(<span class="st">"</span><span class="sc">{}</span><span class="st">'s </span><span class="sc">{}</span><span class="st"> games played"</span>.<span class="bu">format</span>(name, n_sims))</span>
<span id="cb17-85"><a href="#cb17-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-86"><a href="#cb17-86" aria-hidden="true" tabindex="-1"></a>        fig.axes[<span class="dv">0</span>].hist(</span>
<span id="cb17-87"><a href="#cb17-87" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.score_keeper,</span>
<span id="cb17-88"><a href="#cb17-88" aria-hidden="true" tabindex="-1"></a>            bins<span class="op">=</span>np.linspace(<span class="dv">0</span>, max_score, n_bins),</span>
<span id="cb17-89"><a href="#cb17-89" aria-hidden="true" tabindex="-1"></a>            alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb17-90"><a href="#cb17-90" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span>color,</span>
<span id="cb17-91"><a href="#cb17-91" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span>color)</span>
<span id="cb17-92"><a href="#cb17-92" aria-hidden="true" tabindex="-1"></a>        fig.axes[<span class="dv">0</span>].hist(</span>
<span id="cb17-93"><a href="#cb17-93" aria-hidden="true" tabindex="-1"></a>            [<span class="va">self</span>.score_keeper[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_sims) <span class="cf">if</span> <span class="va">self</span>.bonus_keeper[i] <span class="op">==</span> <span class="dv">1</span>],</span>
<span id="cb17-94"><a href="#cb17-94" aria-hidden="true" tabindex="-1"></a>            bins<span class="op">=</span>np.linspace(<span class="dv">0</span>, max_score, n_bins),</span>
<span id="cb17-95"><a href="#cb17-95" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span>color,</span>
<span id="cb17-96"><a href="#cb17-96" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span>color,</span>
<span id="cb17-97"><a href="#cb17-97" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">'got bonus: </span><span class="sc">{:.0f}</span><span class="st">%'</span>.<span class="bu">format</span>(avg_bonus))</span>
<span id="cb17-98"><a href="#cb17-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-99"><a href="#cb17-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-100"><a href="#cb17-100" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> fig.axes[<span class="dv">0</span>].get_legend_handles_labels()</span>
<span id="cb17-101"><a href="#cb17-101" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> [<span class="st">'+ve </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{:.0f}</span><span class="st">%'</span>.<span class="bu">format</span>(hands[i][:<span class="dv">5</span>],<span class="dv">100</span><span class="op">*</span>np.mean(hand_matrix[:,i] <span class="op">!=</span> <span class="dv">0</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>,<span class="dv">12</span>)]</span>
<span id="cb17-102"><a href="#cb17-102" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> [<span class="st">'avg score: </span><span class="sc">{:.2f}</span><span class="st">'</span>.<span class="bu">format</span>(avg_score)] <span class="op">+</span> y</span>
<span id="cb17-103"><a href="#cb17-103" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> fig.axes[<span class="dv">0</span>].legend(</span>
<span id="cb17-104"><a href="#cb17-104" aria-hidden="true" tabindex="-1"></a>            [x[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(y)<span class="op">+</span><span class="dv">1</span>)], </span>
<span id="cb17-105"><a href="#cb17-105" aria-hidden="true" tabindex="-1"></a>            [x[<span class="dv">1</span>][<span class="dv">0</span>],<span class="op">*</span>y], </span>
<span id="cb17-106"><a href="#cb17-106" aria-hidden="true" tabindex="-1"></a>            handlelength<span class="op">=</span><span class="fl">0.7</span>, </span>
<span id="cb17-107"><a href="#cb17-107" aria-hidden="true" tabindex="-1"></a>            prop<span class="op">=</span>{<span class="st">'family'</span>:<span class="st">'monospace'</span>}</span>
<span id="cb17-108"><a href="#cb17-108" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb17-109"><a href="#cb17-109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(y)):</span>
<span id="cb17-110"><a href="#cb17-110" aria-hidden="true" tabindex="-1"></a>            x.legendHandles[i<span class="op">+</span><span class="dv">1</span>].<span class="bu">set</span>(visible<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-111"><a href="#cb17-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-112"><a href="#cb17-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">10</span>):</span>
<span id="cb17-113"><a href="#cb17-113" aria-hidden="true" tabindex="-1"></a>            fig.axes[i].hist(</span>
<span id="cb17-114"><a href="#cb17-114" aria-hidden="true" tabindex="-1"></a>                hand_matrix[:,i<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>(i <span class="cf">if</span> i<span class="op">&lt;=</span><span class="dv">6</span> <span class="cf">else</span> <span class="dv">1</span>),</span>
<span id="cb17-115"><a href="#cb17-115" aria-hidden="true" tabindex="-1"></a>                bins<span class="op">=</span>np.arange(<span class="op">-</span><span class="fl">.5</span>,<span class="fl">6.5</span>) <span class="cf">if</span> i<span class="op">&lt;=</span><span class="dv">6</span> <span class="cf">else</span> np.arange(<span class="op">-</span><span class="fl">0.5</span>,<span class="fl">31.5</span>),</span>
<span id="cb17-116"><a href="#cb17-116" aria-hidden="true" tabindex="-1"></a>                density<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb17-117"><a href="#cb17-117" aria-hidden="true" tabindex="-1"></a>                histtype<span class="op">=</span><span class="st">'bar'</span> <span class="cf">if</span> i<span class="op">&lt;=</span><span class="dv">6</span> <span class="cf">else</span> <span class="st">'stepfilled'</span>,</span>
<span id="cb17-118"><a href="#cb17-118" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb17-119"><a href="#cb17-119" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span>color,</span>
<span id="cb17-120"><a href="#cb17-120" aria-hidden="true" tabindex="-1"></a>                edgecolor<span class="op">=</span>color</span>
<span id="cb17-121"><a href="#cb17-121" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb17-122"><a href="#cb17-122" aria-hidden="true" tabindex="-1"></a>            fig.axes[i].set_title(hands[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb17-123"><a href="#cb17-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-124"><a href="#cb17-124" aria-hidden="true" tabindex="-1"></a>        plt.tight_layout()</span>
<span id="cb17-125"><a href="#cb17-125" aria-hidden="true" tabindex="-1"></a>        <span class="co">#plt.savefig('{}'.format(name.replace(' ', '-').lower()), facecolor='white')</span></span>
<span id="cb17-126"><a href="#cb17-126" aria-hidden="true" tabindex="-1"></a>        plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> randomYachtDiceAgent(yachtDiceAgent):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, state_policy_dict, init_availHandsId<span class="op">=</span><span class="dv">0</span>, init_game_score<span class="op">=</span><span class="dv">0</span>, init_bonus_progress<span class="op">=</span><span class="dv">0</span>, random_hands<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(state_policy_dict, init_availHandsId, init_game_score, init_bonus_progress)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.random_hands <span class="op">=</span> random_hands</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_action(<span class="va">self</span>, availHandsId, bonus_progress, rerolls_left, diceRollId):</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rerolls_left <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.random_hands:</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>) <span class="cf">if</span> available_hands[availHandsId][i] <span class="op">==</span> <span class="st">'0'</span>]</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> x[np.random.randint(<span class="bu">len</span>(x))]</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">self</span>.state_policy_dict[<span class="dv">0</span>][availHandsId, diceRollId]</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.random.randint(<span class="dv">32</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our first bot makes decisions completely at random.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> randomYachtDiceAgent(old_state_policy_dict)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Random Agent'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/random-agent.png" class="img-fluid"></p>
<p>This is a bit mean so we’ll update it to only randomize the rerolls so it can select the highest scoring hand at the end of the round.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> randomYachtDiceAgent(old_state_policy_dict, random_hands<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Semi-Random Agent'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/semi-random-agent.png" class="img-fluid"></p>
<p>Our next bot operates using the greedy policy we’ve created. It scores significantly higher than our random agent.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(old_state_policy_dict)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Greedy Agent'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/greedy-agent.png" class="img-fluid"></p>
<p>As previously addressed, greed is not always optimal. We need to teach the bots to weigh long term opportunities against cashing in on short term rewards. To do this we’ll adjust the behaviour of new agents by altering their preceived hand values prior to creating a greedy policy. Let’s make the next bot by subtracting the expected value of each hand at the start of the turn from it’s original value. It scores roughly 15 points higher on average.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>new_hand_value_matrix <span class="op">=</span> base_hand_value_matrix <span class="op">-</span> ex_val_preroll</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(new_hand_value_matrix))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Expected Value Agent'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/expected-value-agent.png" class="img-fluid"></p>
<p>Our new bot obtains the bonus roughly 10% of the time. Factoring the bonus into our decision making process is definetly worth exploring if we want to best our new average. Let’s try to make a bot that prioritizes reaching the bonus so we can see just how frequently one can obtain it. We’ll restrict ourselves to only manipulating the base hand values without including additional information like the current bonus progress in our transformations. This is suboptimal but keeps the policy creation time at a minimum.</p>
<p>Here’s a naive approach. The bonus requires scoring a total of 63 points from all the single digit hands. 63 can be achieved by scoring at least a 3 count for each digit, 63 = 3*(1+2+3+4+5+6). Let’s transform the base hand values such that our bot overvalues anything higher than a 3 count and fears picking anything less.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> base_hand_value_matrix.copy()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co"># punish anything below a 3 count for bonus hands</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>x[x <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">*</span> np.arange(<span class="dv">1</span>,<span class="dv">13</span>) <span class="op">*</span> (np.arange(<span class="dv">12</span>) <span class="op">&lt;</span> <span class="dv">6</span>)] <span class="op">-=</span> <span class="dv">100</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># reward anything above a 3 count for bonus hands</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>x[x <span class="op">&gt;=</span> <span class="dv">3</span> <span class="op">*</span> np.arange(<span class="dv">1</span>,<span class="dv">13</span>) <span class="op">+</span> <span class="dv">100</span><span class="op">*</span>(np.arange(<span class="dv">12</span>) <span class="op">&gt;=</span> <span class="dv">6</span>)] <span class="op">+=</span> <span class="dv">100</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(x))</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Bonus Agent'</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/bonus-agent.png" class="img-fluid"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># lets check the prob of getting at least a 3 count using the same method for finding the expected values but</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># convert base_hand_value_matrix into a binary matrix with ones only at acceptable results</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> base_hand_value_matrix<span class="op">-</span>base_hand_value_matrix.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)<span class="op">*</span>(<span class="dv">3</span><span class="op">/</span><span class="dv">5</span>)<span class="op">&gt;=</span><span class="dv">0</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">*=</span> (np.arange(<span class="dv">12</span>) <span class="op">&lt;</span> <span class="dv">6</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>prob_1_reroll_left <span class="op">=</span> np.einsum(<span class="st">'ijk,kl-&gt;ijl'</span>,state_transition_matrix,x.astype(<span class="bu">int</span>)).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>prob_2_reroll_left <span class="op">=</span> np.einsum(<span class="st">'ijk,kl-&gt;ijl'</span>,state_transition_matrix,prob_1_reroll_left).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>prob_preroll <span class="op">=</span> state_transition_matrix[<span class="dv">0</span>,keeps.index(<span class="st">'00000'</span>),:] <span class="op">@</span> prob_2_reroll_left</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>prob_preroll[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.35484999797783096</code></pre>
<p>The bonus agent achieves it’s goal roughly 90% of the time. This might seem high if you consider the probability of getting a 3 count above but there’s a lot of mechanisms working in our favour. First, the bot uses the six non bonus hands to dump any undesirable results. Second, the probability above is calculated as if we chose the hand prior to seeing the initial roll for the round, in game we use the knowledge obtained from that roll to determine what to pursue. Finally, scoring higher than a 3 count can ease the minimum count required for other hands.</p>
<p>Let’s try one last bot whose only desire is to pursue the perfect game.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># lets check the prob of getting a max score for each hand using same method for finding the expected values but</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"># convert base_hand_value_matrix into a binary matrix with ones only at acceptable results</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> base_hand_value_matrix<span class="op">-</span>base_hand_value_matrix.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)<span class="op">==</span><span class="dv">0</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>prob_1_reroll_left <span class="op">=</span> np.einsum(<span class="st">'ijk,kl-&gt;ijl'</span>,state_transition_matrix,mask.astype(<span class="bu">int</span>)).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>prob_2_reroll_left <span class="op">=</span> np.einsum(<span class="st">'ijk,kl-&gt;ijl'</span>,state_transition_matrix,prob_1_reroll_left).<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>prob_preroll <span class="op">=</span> state_transition_matrix[<span class="dv">0</span>,keeps.index(<span class="st">'00000'</span>),:] <span class="op">@</span> prob_2_reroll_left</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="bu">dict</span>(<span class="bu">zip</span>(hands,prob_preroll))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>{'ones': 0.013272056011374675,
 'twos': 0.01327205601137467,
 'threes': 0.013272056011374662,
 'fours': 0.013272056011374652,
 'fives': 0.013272056011374659,
 'sixes': 0.013272056011374652,
 'choice': 0.013272056011374652,
 'fourKind': 0.013272056011374652,
 'fullHouse': 0.013272056011374652,
 'smallStraight': 0.6154423129036065,
 'largeStraight': 0.2610950167341143,
 'yacht': 0.04602864252569902}</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(mask))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Perfect Game Agent'</span>, color<span class="op">=</span><span class="st">'purple'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/perfect-game-agent.png" class="img-fluid"></p>
<p>so close…</p>
<p>To defeat our current champion we’ll need to spend more time thinking up which reward transformations can express potentially desireable behaviours. Let’s plot the expected value agent’s transformations. What kind of behaviour do you expect from the bot if it finished rolling with five sixes? Would you rather select 30 points and a chunk of bonus progress by picking “sixes” or cash in on 50 points from a yacht hand? What about “sixes” vs four of a kind? Are you more certain in your decision if you rolled five ones instead? What determines when we use a binary hand to dump an unwanted roll? How can we tinker with the rewards to answer these questions?</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>possible_hand_scores <span class="op">=</span> [np.unique(base_hand_value_matrix[:,i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>)]</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>n_possible_values <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    n_possible_values <span class="op">+=</span> <span class="bu">len</span>(possible_hand_scores[i])</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There's a total of </span><span class="sc">{</span>n_possible_values<span class="sc">}</span><span class="ss"> values that can be manipulated to produce new policies."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>There's a total of 120 values that can be manipulated to produce new policies.</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_reward_transformations(hand_value_matrix):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, sharey<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">6</span>))</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    fig.subplots_adjust(wspace<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    titles <span class="op">=</span> [<span class="st">'Bonus Hands'</span>,<span class="st">'Standard Hands'</span>,<span class="st">'Binary Hands'</span>]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    x_labels <span class="op">=</span> [<span class="st">'counts'</span>,<span class="st">'base hand value'</span>,<span class="st">'achieved'</span>]</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    x_ticks <span class="op">=</span> [np.arange(<span class="dv">6</span>),np.linspace(<span class="dv">0</span>,<span class="dv">30</span>,<span class="dv">6</span>),[<span class="dv">0</span>,<span class="dv">1</span>]]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    fig.suptitle(<span class="st">'Reward Transformations'</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].set_ylabel(<span class="st">'new hand value'</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>):</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i<span class="op">//</span><span class="dv">6</span> <span class="op">+</span> i<span class="op">//</span><span class="dv">9</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>        denom <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span> <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> j <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="bu">max</span>(possible_hand_scores[i])</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        ax[j].scatter(</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>            possible_hand_scores[i]<span class="op">/</span>denom,</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>            <span class="bu">sorted</span>(np.unique(hand_value_matrix[:,i])), </span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span>hands[i])</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        ax[j].set_xticks(x_ticks[j])</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>        ax[j].set_xlabel(x_labels[j])</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        ax[j].legend()</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>        ax[j].set_title(titles[j])</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plt.savefig('reward-transform', facecolor='white')</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>plot_reward_transformations(new_hand_value_matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/reward-transform.png" class="img-fluid"></p>
<p>Let’s inspect how the bot orders selecting each available hand after rolling five sixes. We’ll also play out 1000 games after selecting each hand as if we rolled it on first turn.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>roll <span class="op">=</span> <span class="st">'66666'</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> base_hand_value_matrix[rolls.index(roll)]</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>new_values <span class="op">=</span> new_hand_value_matrix[rolls.index(roll)]</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> []</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co"># create agent</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(new_hand_value_matrix))</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>):</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># init game after first turn</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    bot.init_availHandsId <span class="op">=</span> available_hands.index(<span class="st">''</span>.join([<span class="st">'1'</span> <span class="cf">if</span> k <span class="op">==</span> i <span class="cf">else</span> <span class="st">'0'</span> <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>)]))</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    bot.init_game_score <span class="op">=</span> values[i]</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    bot.init_bonus_progress <span class="op">=</span> values[i]<span class="op">*</span>(i <span class="op">&lt;</span> <span class="dv">6</span>)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    bot.score_keeper <span class="op">=</span> []</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    bot.simulate_games(<span class="dv">1000</span>)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    scores.append(np.mean(bot.score_keeper))</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"First Turn diceRoll: </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(roll), fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"average final score after selection in 1000 games"</span>)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_visible(<span class="va">False</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> ax.twiny() </span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">3.2</span>)</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">"bot's preceived hand value"</span>)</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>ax1.plot(</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sorted</span>(new_values), </span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span><span class="op">*</span>np.ones_like(new_values),</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    linewidth<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    solid_capstyle<span class="op">=</span><span class="st">'round'</span>,</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">'k'</span>,</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>    zorder<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>ax.plot(</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sorted</span>(scores),</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    np.zeros_like(scores),</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    linewidth<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    solid_capstyle<span class="op">=</span><span class="st">'round'</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>    ,color<span class="op">=</span><span class="st">'k'</span>,</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>    zorder<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>):</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    temp_x <span class="op">=</span> <span class="bu">min</span>(new_values) <span class="op">+</span> (<span class="bu">max</span>(new_values) <span class="op">-</span> <span class="bu">min</span>(new_values))<span class="op">*</span>(scores[i] <span class="op">-</span> <span class="bu">min</span>(scores)) <span class="op">/</span> (<span class="bu">max</span>(scores) <span class="op">-</span> <span class="bu">min</span>(scores))</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    ax1.plot(</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>        [new_values[i], new_values[i], temp_x, temp_x],</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>        <span class="st">'-.'</span> <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">5</span> <span class="cf">else</span> <span class="st">'-'</span>,</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>hands[i]</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>    ax1.scatter(new_values[i], <span class="dv">3</span>, marker<span class="op">=</span><span class="dv">7</span> <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">5</span> <span class="cf">else</span> <span class="dv">6</span>)</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>    ax.scatter(scores[i], <span class="dv">0</span>, marker<span class="op">=</span><span class="dv">6</span> <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">5</span> <span class="cf">else</span> <span class="dv">7</span>)</span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>ax1.legend(</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>    bbox_to_anchor<span class="op">=</span>(<span class="fl">1.01</span>, <span class="fl">.5</span>),</span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    loc<span class="op">=</span><span class="st">'center left'</span></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/handtoscore-transform.png" class="img-fluid"></p>
<p>This bot won’t pick sixes over full house or four of a kind but if we intervene to force sixes the bot ends up improving greatly. How can we transform the preceived hand values to accommodate this? Can we attempt to do this automatically?</p>
<p>Let’s convert each hand value to it’s average final score by following the rungs on the ladder plot above. We’ll need to do this for every roll then repeat to see if we can converge on a final strategy.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>num_games <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>num_iters <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {i: {<span class="st">'n_sims'</span>:num_games<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>),<span class="st">'avg_score'</span>:<span class="dv">0</span>} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_iters)}</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>new_hand_value_matrix <span class="op">=</span> base_hand_value_matrix.copy()</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(new_hand_value_matrix))</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> results:</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    n_sims <span class="op">=</span> results[t][<span class="st">'n_sims'</span>]</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># keep newly calculated hand values here before updating hand_value_matrix</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    store_hand_value <span class="op">=</span> {}</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># bonus hands</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>):</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        store_hand_value[i] <span class="op">=</span> []</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initiate sims from this gamestate (after first turn)</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>        bot.init_availHandsId <span class="op">=</span> available_hands.index(<span class="st">''</span>.join([<span class="st">'1'</span> <span class="cf">if</span> k <span class="op">==</span> i <span class="cf">else</span> <span class="st">'0'</span> <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">13</span>)]))</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>        bot.bonus_keeper <span class="op">=</span> []</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>        bot.score_keeper <span class="op">=</span> []</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>        bot.hand_keeper <span class="op">=</span> []</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>        bot.simulate_games(n_sims)</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>):</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>            hand_matrix <span class="op">=</span> np.vstack(bot.hand_keeper)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># add bonus progress achieved in simulation with bonus progress from initiated hand</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>            bonus_prog <span class="op">=</span> hand_matrix[:,:<span class="dv">6</span>].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>) <span class="op">+</span> np.tile(i<span class="op">*</span>j,n_sims)</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>            store_hand_value[i].append(</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>                np.mean(</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>                    bot.score_keeper <span class="op">+</span> np.tile(i<span class="op">*</span>j,n_sims) <span class="op">+</span> np.where((bonus_prog <span class="op">&gt;=</span> <span class="dv">63</span>) <span class="op">!=</span> bot.bonus_keeper, <span class="dv">35</span>, <span class="dv">0</span>)</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># non bonus hands</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>,<span class="dv">13</span>):</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initiate sims from this gamestate (after first turn with best possible score)</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>        bot.init_availHandsId <span class="op">=</span> available_hands.index(<span class="st">''</span>.join([<span class="st">'1'</span> <span class="cf">if</span> k <span class="op">==</span> i <span class="cf">else</span> <span class="st">'0'</span> <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">13</span>)]))</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>        bot.score_keeper <span class="op">=</span> []</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>        bot.simulate_games(n_sims)</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>        store_hand_value[i] <span class="op">=</span> possible_hand_scores[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> np.mean(bot.score_keeper)</span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># replace hand values </span></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>    new_hand_value_matrix <span class="op">=</span> np.zeros_like(base_hand_value_matrix)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> store_hand_value:</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(store_hand_value[i])):</span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>            new_hand_value_matrix[np.where(base_hand_value_matrix[:,i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> possible_hand_scores[i<span class="op">-</span><span class="dv">1</span>][j]), i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> store_hand_value[i][j]</span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create and evaluate new bot</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>    bot <span class="op">=</span> yachtDiceAgent(create_simple_policy(new_hand_value_matrix))</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>    bot.simulate_games(n_sims)</span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>    results[t][<span class="st">'avg_score'</span>] <span class="op">=</span> np.mean(bot.score_keeper)</span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="sc">{}</span><span class="st"> in </span><span class="sc">{}</span><span class="st"> games'</span>.<span class="bu">format</span>(results[t][<span class="st">'avg_score'</span>], n_sims))</span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a>bot.summarize_results(name<span class="op">=</span><span class="st">'Contender'</span>, color<span class="op">=</span><span class="st">'teal'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>181.365 in 1000 games
184.879 in 2000 games
186.61633333333333 in 3000 games
187.674 in 4000 games
186.2746 in 5000 games</code></pre>
<p><img src="images/contender.png" class="img-fluid"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>plot_reward_transformations(final_hand_value_matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/reward-transform-1.png" class="img-fluid"></p>
<p>We’ve bested our previous record by roughly 7 points! By plotting the reward transformations, two changes become apparent. First, our procedure naturally incorporated the bonus value into the single digit hands. Second, the new agent will dump a bad round on a small straight before a large straight. It is also noteworthy that all the previous agents will converged to this final one (even the perfect game agent).</p>
<p>Is this the best we can do? No, our bots are restricted to static hand values ignoring any information gained during the game. This is a pretty good result managed within 3 minutes. Let’s see what happens if we include available hands and bonus progress in the decision making process. We’ll acheive this in a similar manner except the new rewards at each state will be the sum of the current reward and expected value of total points from the resulting next state to the end of the game. We’ll be working backwards from the last round to the first calculating new policy along the way. This will take a long time if we’re not careful, I’ve managed to reduce it to roughly 10 minutes by combining states that will have identical strategies.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get available hands for each turn number </span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>available_hands_in_turn <span class="op">=</span> {i:[] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>)}</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_available_hands):</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    available_hands_in_turn[available_hands[i].count(<span class="st">'1'</span>)].append(i)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co"># include bonus progress in representing state</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co"># determine all relevent bonus progress values for each available hands combo</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co"># relevent = changes strategy and is possible to obtain for said round </span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co"># matrix to map any irrelevent states to relevent ones</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>relevent_bonus_mapping <span class="op">=</span> np.zeros((n_available_hands, <span class="dv">64</span>))</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>relevent_bonus_testing <span class="op">=</span> {}</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_available_hands):</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    avail_bonus_hands <span class="op">=</span> [j<span class="op">+</span><span class="dv">1</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>) <span class="cf">if</span> available_hands[i][j] <span class="op">==</span> <span class="st">'0'</span>]</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    used_bonus_hands <span class="op">=</span> [j <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>) <span class="cf">if</span> j <span class="kw">not</span> <span class="kw">in</span> avail_bonus_hands]</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    need_to_test_progs <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>([<span class="dv">0</span>] <span class="op">+</span> [<span class="dv">63</span> <span class="op">-</span> <span class="bu">min</span>(<span class="dv">63</span>, <span class="bu">sum</span>(j)) <span class="cf">for</span> j <span class="kw">in</span> itertools.product(<span class="op">*</span>[i<span class="op">*</span>np.arange(<span class="dv">6</span>) <span class="cf">for</span> i <span class="kw">in</span> avail_bonus_hands])])))</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    maximum_possible_prog <span class="op">=</span> <span class="bu">min</span>(<span class="dv">63</span>, <span class="dv">5</span><span class="op">*</span><span class="bu">sum</span>(used_bonus_hands))</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    relevent_bonus_testing[i] <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> need_to_test_progs <span class="cf">if</span> i <span class="op">&lt;=</span> maximum_possible_prog] </span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> relevent_bonus_testing[i] <span class="op">+</span> [<span class="dv">64</span>]</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        relevent_bonus_mapping[i, x[j]:x[j<span class="op">+</span><span class="dv">1</span>]] <span class="op">=</span> x[j]</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a><span class="co"># include post final round</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>relevent_bonus_mapping <span class="op">=</span> np.vstack([relevent_bonus_mapping, relevent_bonus_mapping[<span class="dv">4094</span>]])</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'number of states to calculate: </span><span class="sc">{</span><span class="bu">sum</span>(<span class="bu">len</span>(relevent_bonus_testing[i]) <span class="cf">for</span> i <span class="kw">in</span> relevent_bonus_testing)<span class="sc">}</span><span class="ss"> out of </span><span class="sc">{</span>n_available_hands<span class="op">*</span><span class="dv">64</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>number of states to calculate: 119870 out of 262080</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># initiate policy dict</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>state_policy_dict <span class="op">=</span> {}</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    state_policy_dict[i] <span class="op">=</span> np.transpose(np.repeat(old_state_policy_dict[i][:,:,np.newaxis], <span class="dv">64</span>, axis<span class="op">=</span><span class="dv">2</span>), axes<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>])</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>BranchingStates <span class="op">=</span> {}</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co"># end game calc bonus</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>BranchingStates[<span class="dv">4095</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>BranchingStates[<span class="dv">4095</span>,<span class="dv">63</span>] <span class="op">=</span> <span class="dv">35</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> turn <span class="kw">in</span> np.arange(<span class="dv">11</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(turn)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ah_idx <span class="kw">in</span> available_hands_in_turn[turn]:</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> bp_idx <span class="kw">in</span> relevent_bonus_testing[ah_idx]:</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># make new policy by imputing hand values</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> np.zeros_like(base_hand_value_matrix) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>            hand_options <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>) <span class="cf">if</span> available_hands[ah_idx][i] <span class="op">==</span> <span class="st">'0'</span>]</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> h <span class="kw">in</span> hand_options:</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>                next_ah_idx <span class="op">=</span> ah_idx <span class="op">+</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">11</span><span class="op">-</span>h)</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> p <span class="kw">in</span> possible_hand_scores[h]:</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>                    next_bp_idx <span class="op">=</span> <span class="bu">int</span>(<span class="bu">min</span>(<span class="dv">63</span>, bp_idx <span class="op">+</span> p<span class="op">*</span>(h <span class="op">&lt;</span> <span class="dv">6</span>)))</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>                    adj_next_bp_idx <span class="op">=</span> relevent_bonus_mapping[next_ah_idx, next_bp_idx]</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>                    x[np.where(base_hand_value_matrix[:,h]<span class="op">==</span>p),h] <span class="op">=</span> (p <span class="op">+</span> BranchingStates[next_ah_idx, adj_next_bp_idx])</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get all affected bonus progresses</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> j <span class="kw">in</span> relevent_bonus_testing[ah_idx] <span class="cf">if</span> bp_idx <span class="op">&gt;=</span> j) </span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> y <span class="op">&gt;=</span> <span class="bu">len</span>(relevent_bonus_testing[ah_idx]):</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> relevent_bonus_testing[ah_idx][y]</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># make new policy and calculate expected value of state</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>            state_policy_dict[<span class="dv">0</span>][ah_idx, bp_idx:z, :] <span class="op">=</span> np.argmax(x, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>            value_0 <span class="op">=</span> x.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> np.einsum(<span class="st">'i,jki-&gt;jk'</span>,value_0, state_transition_matrix)</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>            state_policy_dict[<span class="dv">1</span>][ah_idx, bp_idx:z, :] <span class="op">=</span> np.argmax(a, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>            value_1 <span class="op">=</span> a.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> np.einsum(<span class="st">'i,jki-&gt;jk'</span>,value_1, state_transition_matrix)</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>            state_policy_dict[<span class="dv">2</span>][ah_idx, bp_idx:z, :] <span class="op">=</span> np.argmax(a, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>            value_2 <span class="op">=</span> a.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>            BranchingStates[ah_idx, bp_idx] <span class="op">=</span> value_2 <span class="op">@</span> initial_roll_probs</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'This bot</span><span class="ch">\'</span><span class="ss">s expected score is </span><span class="sc">{</span>BranchingStates[<span class="dv">0</span>,<span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>This bot's expected score is 191.77436918834172</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>plot_reward_transformations(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/reward-transform-2.png" class="img-fluid"></p>
<p>The final bot’s first round reward transformations look very similar to our previous contender.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> newYachtDiceAgent(yachtDiceAgent):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, state_policy_dict, init_availHandsId<span class="op">=</span><span class="dv">0</span>, init_game_score<span class="op">=</span><span class="dv">0</span>, init_bonus_progress<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(state_policy_dict, init_availHandsId, init_game_score, init_bonus_progress)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_action(<span class="va">self</span>, availHandsId, bonus_progress, rerolls_left, diceRollId):</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.state_policy_dict[rerolls_left][availHandsId, bonus_progress, diceRollId]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>new_bot <span class="op">=</span> newYachtDiceAgent(</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    state_policy_dict,</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>new_bot.simulate_games(<span class="dv">10000</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>new_bot.summarize_results(name<span class="op">=</span><span class="st">'Johnny Yacht Dice'</span>, color<span class="op">=</span><span class="st">'royalblue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="images/johnny-yacht-dice.png" class="img-fluid"></p>
<p>One last thing, we can calculate the probability of getting a perfect game now.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>perfect_hand_value_matrix <span class="op">=</span> (base_hand_value_matrix<span class="op">-</span>base_hand_value_matrix.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)<span class="op">==</span><span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>perfect_policy_dict <span class="op">=</span> {}</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    perfect_policy_dict[i] <span class="op">=</span> old_state_policy_dict[i].copy()</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>BranchingPerfects <span class="op">=</span> {}</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>BranchingPerfects[<span class="dv">4095</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> turn <span class="kw">in</span> np.arange(<span class="dv">11</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ah_idx <span class="kw">in</span> available_hands_in_turn[turn]:</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.zeros_like(base_hand_value_matrix) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>        hand_options <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>) <span class="cf">if</span> available_hands[ah_idx][i] <span class="op">==</span> <span class="st">'0'</span>]</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> h <span class="kw">in</span> hand_options:</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>            x[:,h] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>            next_ah_idx <span class="op">=</span> ah_idx <span class="op">+</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">11</span><span class="op">-</span>h)</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>            x[np.where(perfect_hand_value_matrix[:,h]<span class="op">==</span><span class="dv">1</span>),h] <span class="op">=</span> <span class="dv">1</span><span class="op">*</span>BranchingPerfects[next_ah_idx]</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># make new policy and calculate expected value of state</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>        perfect_policy_dict[<span class="dv">0</span>][ah_idx, :] <span class="op">=</span> np.argmax(x, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>        value_0 <span class="op">=</span> x.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> np.einsum(<span class="st">'i,jki-&gt;jk'</span>,value_0, state_transition_matrix)</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>        perfect_policy_dict[<span class="dv">1</span>][ah_idx, :] <span class="op">=</span> np.argmax(a, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>        value_1 <span class="op">=</span> a.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> np.einsum(<span class="st">'i,jki-&gt;jk'</span>,value_1, state_transition_matrix)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>        perfect_policy_dict[<span class="dv">2</span>][ah_idx, :] <span class="op">=</span> np.argmax(a, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>        value_2 <span class="op">=</span> a.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>        BranchingPerfects[ah_idx] <span class="op">=</span> value_2 <span class="op">@</span> initial_roll_probs</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'It will take on average </span><span class="sc">{</span><span class="dv">1</span><span class="op">/</span>BranchingPerfects[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> games to achieve a perfect one'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>It will take on average 276939929515183.94 games to achieve a perfect one</code></pre>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>